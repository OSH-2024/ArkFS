# **ArkFS 结题报告**

- [0 成员介绍](#0-成员介绍)
- [1 项目简介](#1-项目简介)
- [2 解析层](#2-解析层)
  - [2.1 解析层的任务](#21-解析层的任务)
  - [2.2 关键信息的选择](#22-关键信息的选择)
    - [2.2.1 特征词](#221-特征词)
    - [2.2.2 任务调度序列](#222-任务调度序列)
  - [2.3 特征的提取](#23-特征的提取)
    - [2.3.1 本地化方案](#231-本地化方案)
    - [2.3.2 远程方案](#232-远程方案)
  - [2.4 信息的组织](#24-信息的组织)
    - [2.4.1 本地化方案](#241-本地化方案)
    - [2.4.2 远端方案](#242-远端方案)
  - [2.5 多任务复合语句的解决方案](#25-多任务复合语句的解决方案)
- [3 管理层](#3-管理层)
- [4 执行层](#4-执行层)
  - [4.1 文件增添](#41-文件增添)
  - [4.2 文件删除](#42-文件删除)
  - [4.3 文件查找](#43-文件查找)
    - [4.3.1 精确查找](#431-精确查找)
    - [4.3.2 模糊查找](#432-模糊查找)
- [5 应用层](#5-应用层)
  - [5.1 用户输入](#51-用户输入)
  - [5.2 调用流程](#52-调用流程)
  - [5.3 展示与筛选](#53-展示与筛选)
  - [5.4 代码展示](#54-代码展示)
- [6 总结与展望](#6-总结与展望)

## 0 成员介绍

组长：杨柄权 负责管理层 —— 任务队列的建立和“执行层”的精细查询
 
组员：李岱峰 负责解析层 —— 对自然语言命令的解析

组员：常圣 负责执行层 —— 增，删，向量化索引

组员：刘明乐 负责应用层 —— UI界面设计

## 1 项目简介
大语言模型在近几年已取得巨大发展。本项目受AIOS（即大语言模型智能体操作系统）思想启发，旨在利用大语言模型提取文本中的关键信息，形成特征向量传递给任务调度层，通过执行对应操作，实现文件系统的自动化操作，同时验证AIOS的可行性。本项目分为解析层、管理层、执行层和应用层四个部分，其中解析层负责对自然语言命令的解析，管理层负责任务队列的建立，执行层负责增、删、改、查等操作。应用层则负责用户交互界面的设计，实现用户输入、调用流程、展示与筛选等功能。本项目的目标是提高文件系统操作的自动化程度和效率，减少人工干预，提升用户体验。

## 2 解析层

### 2.1 解析层的任务

用大语言模型提取文本中的关键信息，形成特征向量传递给任务调度层

在这一层需要解决的问题：
- 1. 我们需要得到什么关键信息
- 2. 如何提取自然语言的关键信息
- 3. 这些关键信息如何组织，如何传递
- 4. 多任务复合语句的解决方案
  
### 2.2 关键信息的选择

#### 2.2.1 特征词

通过大语言模型提取文本中可以用作文件操作的关键词，如典型的文件特征“时间”、“内容”、“文件类型”等。在本项目中，我们实现了对以上三个特征的提取，若用户的需求不含这三个特征，就以NULL返回。

此外，我们也考虑到了用户的其他需求如：用户指定新文件夹名、用户想要文件夹和文件一起建立、用户还指定文件里有什么内容并要大模型给他生成一篇新东西放进去，等等。这些内容出于我们的处理能力和大模型的处理能力暂且没有加入本次项目中。

大模型对用户自然语言的分析，并提取“特征向量”的过程是一个“压缩”过程，我们将用户的复杂的文本压缩提取出简明的特征值，以便后续操作的进行。

#### 2.2.2 任务调度序列

我们正在开发的主要功能之一就是“任务队列”管理系统，可以根据用户输入自动识别和执行“增删改查”操作。

需求提取:用户想要进行什么操作，大模型将解析用户需求并识别任务队列的需求。例如剪切操作识别为查增删。利用大模型分析用户需求，提取出关键的增删改查操作。将这些操作分类并转换为任务队列中的具体任务。

通过这一系统，我们旨在大幅提高文件系统操作的自动化程度和效率，减少人工干预，从而提升用户体验。


### 2.3 特征的提取

#### 2.3.1 本地化方案

我们使用戴尔 Inspiron 15 5510 设备进行测试，实验大模型选择了llama3-8b。实验的方法是通过ollama本地运行，并使用uvicorn.run(app, host="0.0.0.0", port=8000)将其嵌入到程序内。

具体步骤如下：

- 设置本地环境，安装必要的依赖库。
- 配置ollama运行环境，并加载llama3-8b大模型。
- 编辑Modelfile，限制回答方式和返回值
- 使用Uvicorn启动本地服务器，监听所有IP地址，端口设置为8000。

实验过程中，发现以下问题：

- 生成速度慢: 在执行生成任务时，模型的响应速度较慢，影响了整体效率。
- 提取不准确: 模型在从用户需求中提取关键信息的准确性不高，导致生成的任务队列存在错误。
- 任务队列不符合要求: 由于提取信息不准确，生成的任务队列未能完全符合预期的需求和规范。

尽管在本地运行大模型具有一定的可行性，但在生成速度、信息提取准确性和任务队列管理方面仍存在较多问题。后续需要优化模型的运行效率和准确性，以满足实际应用的需求。

![Alt](pics/test_model.png)

我们已经验证了这种方案的可行性，但由于运行效率和准确性，我们没有选择这种方案作为最终程序。

#### 2.3.2 远程方案

通过远程API实现任务队列管理的方法，效果显著。该方法简单有效，能够迅速处理和返回任务结果。

![Alt](pics/test_model2.png)

我们可以将这样的一段话统一发给远端gpt模型，然后接收返回值。

这样的方式简单有效，返回值易于处理，返回内容精确。这是我们在最终程序中使用的方法。

### 2.4 信息的组织

#### 2.4.1 本地化方案

- 约定返回值格式：对返回的文本内容进行标准化约定，包括时间、文件类型、内容名词和调度序列四个主要部分。
- 编写提取函数：使用Python编写一个函数，从返回的文本中提取出各个关键信息，并将其组织成易于使用的字典结构。

```python
def extract_information(input_text: str):
    lines = input_text.split('\n')
    result = {
        "时间": "",
        "文件类型": "",
        "内容名词": "",
        "调度序列": ""
    }

    for line in lines:
        if line.startswith("1. 时间:"):
            result["时间"] = line.split(":")[1].strip()
        elif line.startswith("2. 文件类型:"):
            result["文件类型"] = line.split(":")[1].strip()
        elif line.startswith("3. 内容名词:"):
            result["内容名词"] = line.split(":")[1].strip()
        elif line.startswith("4. 调度序列:"):
            result["调度序列"] = line.split(":")[1].strip()

    return result

```

#### 2.4.2 远端方案

- def recognize_speech_from_mic():  语音转文字模块
- def parse_operations(param)  将一些字符串映射，如任务序列映射
- def standard(user_input)         将返回字符串进行整理(分列表，不合规返回值修正)
- def map_relative_time_to_iso(time_str) 将时间转换为具体的iso时间

经过上述一系列函数，我们将远端返回的字符串转换为标准格式：
[['时间起始', '时间终止'], '文件类型(image/txt)', ['content', '路径(暂无)'], '任务序列']

其中时间为iso时间，任务队列为整数字符串如'301'(表示查增删)，content为模糊化搜索所用的文件内容。

### 2.5 多任务复合语句的解决方案

现在我们能做到“单逻辑”组合任务，即增删改查出现但每种最多不超过一次，例如：“找几张昨天修改的带草的图片，把它们放到一个新文件夹里”。尚不能很准确实现“多逻辑”复合任务，如“找几张昨天修改的带草的图片，把它们放到一个新文件夹里，并把新文件夹改名叫picture，再找一些新的人像的图片放到这个文件夹里”我们需要更多的参数支持。

![Alt](pics/multi_task.png)

如上图，在我们的现有工作基础上，我们可以再加一层大模型处理，将多任务分解为单任务来运行，可以将复杂的任务解析成多个特征向量传递给下层，而下层我们可以说明是支持这样的多个向量的(详见管理层)。

## 3 管理层

TO BE DONE

## 4 执行层

本阶段主要完成文件系统的基本操作，即增、删、改、查。通过接收来自管理层传递的参数，执行相应操作。

### 4.1 文件增添

本模块主要实现了新建和复制两个功能，面向对象既包括了文件也包括了文件夹。其接收的参数格式为`[[src], dst, file/dir, name]`。

为实现上述功能，我们设计了`file_add.py`：

- 首先，判断用户需求是新建还是复制，目前判断依据为`[src]`列表是否为空。若为空，则为新建，否则为复制。
- 然后，判断用户需求的操作对象文件还是文件夹，目前判断依据为`file/dir`。若为0，则为文件，否则为文件夹。
- 最后，根据上述信息，执行新建或复制操作。
   - 新建：`with open(os.path.join(dst, name),"w") as f`/`os.makedirs(os.path.join(dst, name))`
   - 复制：`shutil.copy(address,os.path.join(dst, name))`/`shutil.copytree(address,os.path.join(dst, name))`

### 4.2 文件删除

本模块主要实现了删除功能，面向对象既包括了文件也包括了文件夹。其接收的参数格式为`[path]`。

为实现上述功能，我们设计了`file_delete.py`：
- 由于删除操作是一个比较简单的操作，我们直接调用`os.remove(path)`/`shutil.rmtree(path)`即可。
- 但是，由于上述函数不可撤销，我们可以使用`send2trash`库来实现可撤销的移入回收站操作。

### 4.3 文件查找

#### 4.3.1 精确查找

TO BE DONE

#### 4.3.2 模糊查找

本模块主要实现了模糊查找功能，面向对象为文件，当前可实现对图片以及`.txt`文件的模糊搜索。其接收的参数格式为`[[start_time, end_time], content, target_dir]`。

由于模糊搜索的不确定性，我们需要引入大模型进行相应的自然语言处理以及向量化特征的生成。

为实现上述功能，我们设计了`file_search.py`。引入大模型`CLIP: ViT-B/32`和`T5: t5-small`，并加载预训练模型。`CLIP`模型提供了`model.encode_image(image: Tensor)`和`model.encode_text(text: Tensor)`两个函数，分别用于图片和文本的向量化。但是，由于`CLIP`模型文本上下文限制，因此对于长文本，先使用`T5`模型生成合适长度的摘要再将其传给`CLIP`进行编码即可。生成的特征向量通过归一化后构建Faiss索引，根据`content`的特征向量进行相似度搜索，返回结果。最后根据`[start_time, end_time]`进行时间筛选，返回结果。同时对于相似度阈值进行了设定，以保证搜索结果的准确性。

已模糊搜索“grass”测试结果如下：

![test_search](pics/test_search.jpg)
  
## 5 应用层

### 5.1 用户输入

用户交互界面实现了两种用户输入方式——语音输入以及文字输入。其中，语音输入套在文字输入的外层，语音识别的结果将会直接显示在文字输入的输入框中，用户若是对语音识别的结果有纠正的需求，便可以直接在输入框中进行修改。

![liu1](pics/liu1.png)

### 5.2 调用流程

UI代码作为整个项目的顶层代码，除了需要进行用户的交互任务之外，还负责整个项目的下层函数调用。

首先，用户输入完成之后，UI调用解析层函数，将自然语言字符串原模原样向下传递，对于应用层而言，解析层具体实现完全不可见，从而实现了分层的分工和设计。解析层将会返回一个拥有固定格式的list，其中包含了用户需求中蕴含的关键信息。

其次，应用层对用户的需求解析进行三类划分：
- 需要展示，无需筛选。应用层若发现用户需求为“模糊搜索”或“精确查找”，则将该需求完整传递给管理层。
- 需要展示，需要筛选。应用层若发现用户需求包含“查”（一般我们的参数若包含查，则一定为第一个操作），则将用户需求操作截断为“查”以及后续操作。首先将查操作传递给管理层，待用户进行手动筛选之后，再将筛选结果和后续操作一起传递给管理层，对于整个过程的执行而言，等效于UI（用户）插手将任务队列打断。
- 无需展示，无需筛选。若操作队列中不包含查，则无需展示任何返回，也不需要用户进行勾选，将用户操作完整传递给管理层即可。  
UI与下层代码执行的流程图大致如下：

![liu2](pics/liu2.png)

### 5.3 展示与筛选

管理层进行完“查”的操作之后，将会返回由文件绝对路径组成的列表，UI负责对文件类型进行判断，若为图片，则展示图片的缩略图以及文件路径，若不是图片，则仅仅展示文件路径。此外，当需要筛选的时候，在每个绝对路径右侧都会展示一个勾选框，以便用户进行操作对象的筛选。用户筛选完成后单击confirm按钮，UI将会返回一个由选中的绝对路径组成的list，并将其传递给管理层进行后续操作。演示效果可参见演示视频。参见video文件夹。

### 5.4 代码展示
以下展示用户按下确定按钮之后的执行逻辑，即本项目实际的main函数。

```python
def search():
    global sel_filelist
    user_input = search_entry.get()
    clear()
    #display("请输入一个描述图片信息的句子，例如：“请给我一张昨天修改的带草的图片”。")
    #display("精确化搜索请使用“叫xxx的文件”或“名为xxx的文件”格式。")
    #start Li Daifeng
    is_precise, file_name = aios.is_precise_search(user_input)
    if is_precise:
        display("精确搜索确认")
        #print(f"提取的信息: [['NULL'], ['NULL'], [{file_name}," "], ['4']]")
        get_v = [['NULL'], 'NULL', [file_name,""], '4']
    else:
        get_v=aios.standard(user_input)
        
    #end Li Daifeng
    print(get_v)
    #start Yang Bingquan
    if (get_v[3][0] == '3' or get_v[3][0] == '4') and len(get_v[3]) == 1:
        print("select 1")
        tqueue = task_queue.task_queue(get_v)
        filelist = tqueue.execute()
        print(filelist)
        clear()
        input_paths(filelist, 0)
    elif get_v[3][0] == '3':
        print("select 2")
        get_v1 = get_v.copy()
        get_v2 = get_v.copy()
        get_v1[3] = "3"
        get_v2[3] = get_v[3][1:]
        tqueue = task_queue.task_queue(get_v)
        filelist = tqueue.execute()
        clear()
        input_paths(filelist, 1)
        root.wait_variable(decision_made)
        if decision_made.get() == "go":
            clear()
            decision_made.set("")
        get_v2[2][0] = sel_filelist
        tqueue1 = task_queue.task_queue(get_v2)
        state = tqueue1.execute()
        if state == 0:
            display("已完成")
        else:
            display("出错！请重试")
        sel_filelist.clear()
    else:
        tqueue = task_queue.task_queue(get_v)
        filelist = tqueue.execute()
        clear()
        if filelist == 0:
            display("已完成")
        else:
            display("出错！请重试")


    #end Yang Bingquan
    # Add actual search logic here
```

## 6 总结与展望

TO BE DONE